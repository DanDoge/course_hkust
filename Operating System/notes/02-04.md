### intro

storage hierarchy
- fast, small, costly: higher
- primary storage: directly accessed by cpu
- main mem: only storage that is large and availble to cpu
- secondary storage
    - nvm, speed comparable to main mem, not lose data, but costly
    - ssd: faster, smaller, costly
    - hard-disk: slow; disk->circle-> track->sector; files seperated into blocks forming a linked list; sequential access: fast, but random low
    - caching: data access should follow constraints(small poportion accessed most of times); first check if in cache, if not, copy to cache; cache policy; avg. access time is weighted sum of hit time and miss time, in which the former is orders of magnitude smaller, so decrease miss rate! => locality, temporal and spatial, lru

io subsystem
- os: hide hardware from users
- responsible for
    - mem management: buffering, caching, spooling(overlapping output of job a and input of job b)
    - device-driver
    - driver for specific hardware devices
- dma: directly transmit data from buffer to main mem w/o cpu; rdma: to main mem of a remote computer, e.g. in gpu clusters; but not necessary for slow devices, say keyboard

multiprocessor sys.
- adv.: increased throughput, scalibility, increased reliablity
- types: asymmetric(each processor assigned to specific tasks), symmetric(each processor performs all tasks)
- numa: each cpu holds its own mem., fast when access its own mem. but slow when other cpu's mem.; asymmetric, each cpu has its own locality

operating system
- from a user's view: convenience, good performance
- shared computer: all users happy, utilize resourse
- mobile devices: optimized for uasbility and battery life
- no user interface(e.g. embedding comp. or automobiles): run without intervention
- no universally accepted definition
    but can be devided into 3 components
    - kernel(runs all time)
    - system program(ships with the os, but not part of the kernel)/application program
    - middleware(frameworks provide services to app. dev.)

emulation: interpretate each instruction
virtualization: check if can run w/o interpretation or slightly modify instruction, or run virtualizd/specified os
