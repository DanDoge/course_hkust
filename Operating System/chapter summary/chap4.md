### chapter 04

#### TA's note

motivations and benefits of threads
- process: thread + address space, a thread is a flow of control with in a process, a multithreaded process contains several different flow of control within the same address space
- distinctive feature: concurrency in th eexecution of different threads in one process, if reallized as different processes, it would be grea redundancies and complexities
- introducing the concept of thread
    - a process may invlove performing multiple tasks
    - creating multiple processes is cunbersome, time-consuming and resource-consuming
    - tasks may share codes, data or other resources
    - multiple threads within the same processs eases the job
- thread is an active execution unit
    - each having its threadID, PC, registers adn stacks
    - sharing code, data, files and heap
- each thread represented by a TCB
    - specifies the state of a thread, scheduling and accounting information
    - no difinition of the process if a process has multiple threads, but only the state for each individual thread
- advantages: responsiviness, resource sharing, ecomony, taking better utilizaition of multi-processor architecture
- concurrency / paralleism
    - parallel system can perform more than one task simultaneously on different processors
    - a concurrent system can support more than one task by allowing multiple tasks to make progress interleaved with one another

multi-threading models
- provided at userlevel: user threads or kernel level: kernel threas, all modern OS support kernel threads
    - user level threads are visible only to programmers and unknown to the kernel. thread libraries provide programmers with APIs for creating and managing user threads, e.g. POSIX Pthreads, Windows threads and Java threads
    - there must be a mapping between user threads the kernel threads
        - many-to-one model: many uesr threads mapped to one kernel thread, thread managemeng done by thredas libraries in user space. provides efficiency for user programming with modularity, but the entire process will be blocked if oen thread makes a blocking system call, multiple threads cannot run in parallel in multi-processor systems
        - one-to-one model: each user thread mapped to one kernel thread. provide maximum concurrency, allowing each thread to run when another thread is blocked, and multiple thread to run in parallel on multiprocesors. drawback: creating a kernel thread involves more oerhead, has to be a restriction on the total number of threads supported in a system
        - many-to-many model: many user level threads to eb mapped to a smaller or equal number of kernel threads, better concurrency than many-to-one model, less than one-to-one model, flexible -> no restriction in the number of user threads
        - two-level model: restricts a user-level thread to be bounded to certain kernel thread, not that flexible
- a TCB only associated with a kernel thread, not a user thread, a kernel thread is the only thread CPU executes, it can run a kernel program or a user program, short-term scheduler scheduling kernel threads

threading issues
- fork() duplicate all threads or only the thread that invokes fork(), exec() replace the entire process, fork()+exec(): only duplicate one thread
- creating a thread is more simpler than creating a new process, only handle a new TCB and stack
- singal: synchronous(to the same process that triggered the signal) or asynchronous(generated by an event external to the running procecess)
- thread cancellation: asynchronous(terminate immediately) / deferred(periodically checks whether to terminate, safer for resource reclaim)
- clone(): creates a separate process that sharing the address space of the calling process, flags are used to determine the extent of sharing
